package cipher;

import java.math.BigInteger;
import java.util.Arrays;
import java.util.Random;

/**
 * Represents securely key exchange over a public channel, includes Elgamal 
 * signature algorithm thats ensure protection from attack Man-In-The-Middle.
 */
public class DiffieHellman 
{
	private final static int bitLength = 256;

	
	/** Cryptographic key generated by algorithm */ 
	private BigInteger key;
	/** Byte representation of key */
	private byte[] keyBytes;
	
	/** p - public big prime number, the same for both key exchangers*/
	private BigInteger primePublic;
	/** g - public number - generator of multiplicative group, the same for both key exchangers*/
	private BigInteger generatorPublic;
	/** a - private  number, only first users know it*/
	private BigInteger privateValue;
	/** A - calculated number from private a (A = (g^a)mod(p))*/
	private BigInteger sendingValue;
	/** B - received calculated number by second user*/
	private BigInteger receivedValue;
	/** y1 - received signature of B (part1)*/
	private BigInteger receivedSignature1;
	/** y2 - received signature of B (part2) */
	private BigInteger receivedSignature2;
	
	/** Elgamal signature inner instance */
	private ElGamalSignature elgamal;

	/** Authorization - checking that signature via Elgamal of received B via Diffie-Hellman value is correct */
	private boolean authorized;
	
	/** Constructor */
	public DiffieHellman()
	{
		elgamal = new ElGamalSignature();
		authorized = false;
	}

	/** Generating p and g values, setting Elgamal p=p and d=g values */
	public void generatePublicVars() 
	{
		Random randomizer = new Random();
		primePublic = BigInteger.probablePrime(bitLength, randomizer);
		do 
		{
			generatorPublic = new BigInteger(bitLength, randomizer);
		} while (generatorPublic.compareTo(primePublic.subtract(new BigInteger("1"))) > 0);
		
		elgamal.setPublicBigPrime(primePublic);
		elgamal.setPublicGenerator(generatorPublic);
	}

	/** Generating Diffie-Hellman :  a value, calculating A value and 
	 * setting Elgamal :  generating t, counting b=d^t(modp), generating k, counting k' */
	public void randomizePrivateValue() 
	{
		Random randomizer = new Random();
		do 
		{
			privateValue = new BigInteger(primePublic.bitLength(), randomizer);
		} while (privateValue.compareTo(primePublic.subtract(new BigInteger("1"))) > 0);

		calculateSendingValue();
		elgamal.generatePrivateValue();
	//	elgamal.setPrivateRandomNumber(privateValue);
		elgamal.countPublicValue();
		elgamal.randomPrivateValue();
	}
	
	/** Calculating A=(g^a)modp value */
	public void calculateSendingValue()
	{
		sendingValue = generatorPublic.modPow(privateValue, primePublic);
	}
	
	/** Calculating key=(B^a)modp value , getting bytes of result and initializing keyBytes value*/
	public void generateKey() 
	{
		key = receivedValue.modPow(privateValue, primePublic);
		keyBytes = key.toByteArray();
		keyBytes = Arrays.copyOfRange(keyBytes, 1, keyBytes.length);
	}
	
	/** Uses elgamal methods to check equation d^M = (b^y1 * y1^y2) (modp) */
	public void checkSignature() {
		/** d^M (modp) = g^B (modp) */
		BigInteger left = elgamal.checkSignatureLeft(receivedValue);
		/** b^y1 * y1^y2 (modp) */
		BigInteger right = elgamal.checkSignatureRight(receivedSignature1, receivedSignature2);
		if(left.equals(right))
			authorized = true;
	}

	/** Signing sending value calculating y1,y2 from A via Elgamal methods */
	public void makeSignature()
	{
		elgamal.countSendingValues(sendingValue);
	}

	/** Setting p and g and Elgamal p and d values from given arguments 
	 * @param p public big prime number
	 * @param g public multiplicative group generator
	 */
	public void setPublicVars(BigInteger p, BigInteger g) 
	{
		this.primePublic = p;
		this.generatorPublic = g;
		elgamal.setPublicBigPrime(this.primePublic);
		elgamal.setPublicGenerator(this.generatorPublic);
	}
	
	// GETTERS AND SETTERS
	public void setReceivedValue(BigInteger B) 
	{
		this.receivedValue = B;
	}

	public String getP() 
	{
		return primePublic.toString();
	}

	public String getG() 
	{
		return generatorPublic.toString();
	}

	public String getA() 
	{
		return sendingValue.toString();
	}

	public byte[] getKeyBytes() 
	{
		return keyBytes;
	}

	public void setReceivedSignature1(BigInteger receivedSignature1) 
	{
		this.receivedSignature1 = receivedSignature1;
	}

	public void setReceivedSignature2(BigInteger receivedSignature2) 
	{
		this.receivedSignature2 = receivedSignature2;
	}

	public ElGamalSignature getElgamal() 
	{
		return elgamal;
	}

	public boolean isAuthorized() 
	{
		return authorized;
	}

	public void setPrivateValue(BigInteger privateValue) 
	{
		this.privateValue = privateValue;
	}

	public BigInteger getSendingValue() 
	{
		return sendingValue;
	}

	public BigInteger getKey() 
	{
		return key;
	}

	public void setAuthorized(boolean authorized) {
		this.authorized = authorized;
	}
}
